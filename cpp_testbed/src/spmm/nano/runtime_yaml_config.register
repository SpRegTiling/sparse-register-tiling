#ifdef RASPBERRY_PI
{"nano", [](c4::yml::ConstNodeRef options) -> method_factory_t<S> {
    int vec_width_bits; options["vec_width_bits"] >> vec_width_bits;
    std::string arch; options["arch"] >> arch;
    std::string mapping_id; options["mapping_id"] >> mapping_id;

    int nr = -1;
    if (options.has_child("nr"))
      options["nr"] >> nr;

    std::string split = "M";
    if (options.has_child("split"))
      options["split"] >> split;


    bool packed = false;
    if (options.has_child("packed"))
      options["packed"] >> packed;

    bool load_balance = false;
    if (options.has_child("load_balance"))
      options["load_balance"] >> load_balance;

    return [arch, vec_width_bits, nr, packed, load_balance, mapping_id, split](
      additional_options_t options, SpMMTask<S>& task)
        -> SpMMFunctor<S>* {

      std::string mapping_id_mut = mapping_id;

      if (mapping_id == "filelist") {
        mapping_id_mut = options["mapping_id"];
      }

      ERROR_AND_EXIT_IF(packed && load_balance,
        "Packing and load-balance are not currently "
        "supported together");

      if (load_balance) {
        if (split == "M")
            return new SpMM_SOP<sop::KD_PIFloatLoadBalancedSplitM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
        else
            ERROR_AND_EXIT("Cannot split by " << split << " with load balancing");
      } else {
        if (split == "M")
            return new SpMM_SOP<sop::KD_PIFloatSplitM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
        else if (split == "N")
            return new SpMM_SOP<sop::KD_PIFloatSplitN>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
        else
            ERROR_AND_EXIT("Cannot split by " << split);
      }

      return nullptr;
    };
}}
#else
{"nano", [](c4::yml::ConstNodeRef options) -> method_factory_t<S> {
    int vec_width_bits; options["vec_width_bits"] >> vec_width_bits;
    std::string arch; options["arch"] >> arch;
    std::string mapping_id; options["mapping_id"] >> mapping_id;

    int nr = -1;
    if (options.has_child("nr"))
      options["nr"] >> nr;

    bool packed = false;
    if (options.has_child("packed"))
      options["packed"] >> packed;

    bool load_balance = false;
    if (options.has_child("load_balance"))
      options["load_balance"] >> load_balance;

    std::string outer_schedule = "NKM";
    if (options.has_child("outer_schedule"))
      options["outer_schedule"] >> outer_schedule;

    return [arch, vec_width_bits,  nr, packed, load_balance, mapping_id, outer_schedule](
      additional_options_t options, SpMMTask<S>& task)
        -> SpMMFunctor<S>* {

      std::string mapping_id_mut = mapping_id;

      if (mapping_id == "filelist") {
        mapping_id_mut = options["mapping_id"];
      }

      if (outer_schedule == "NKM") {
        if (load_balance) {
          if (packed) {
            return new SpMM_SOP<sop::KD_IntelFloatLoadBalancedCPackedNKM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          } else {
            return new SpMM_SOP<sop::KD_IntelFloatLoadBalancedNKM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          }
        } else {
          if (packed) {
            return new SpMM_SOP<sop::KD_IntelFloatCPackedNKM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          } else {
            return new SpMM_SOP<sop::KD_IntelFloatNKM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          }
        }
      } else if (outer_schedule == "KNM") {
        if (load_balance) {
          if (packed) {
            return new SpMM_SOP<sop::KD_IntelFloatLoadBalancedCPackedKNM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          } else {
            return new SpMM_SOP<sop::KD_IntelFloatLoadBalancedKNM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          }
        } else {
          if (packed) {
            return new SpMM_SOP<sop::KD_IntelFloatCPackedKNM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          } else {
            return new SpMM_SOP<sop::KD_IntelFloatKNM>
              (get_executor_id(mapping_id_mut, arch, vec_width_bits, nr), mapping_id_mut, task);
          }
        }
      } else {
        ERROR_AND_EXIT("Unknown outer schedule " << outer_schedule);
      }
      return nullptr;
    };
}}
#endif